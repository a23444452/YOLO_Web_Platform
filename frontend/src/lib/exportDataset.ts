import JSZip from 'jszip';
import type { Dataset, ImageAnnotation, ClassDefinition } from '@/types';

export interface ExportOptions {
  includeImages: boolean;
  splitFolders: boolean;
  filename: string;
}

export interface ExportProgress {
  current: number;
  total: number;
  phase: 'preparing' | 'images' | 'labels' | 'config' | 'compressing';
  message: string;
}

type ProgressCallback = (progress: ExportProgress) => void;

/**
 * 將 BoundingBox 轉換為 YOLO 格式標註行
 * 格式: <class_id> <x_center> <y_center> <width> <height>
 */
function boxToYOLOLine(box: { classId: number; x: number; y: number; width: number; height: number }): string {
  return `${box.classId} ${box.x.toFixed(6)} ${box.y.toFixed(6)} ${box.width.toFixed(6)} ${box.height.toFixed(6)}`;
}

/**
 * 從 dataUrl 中提取 base64 資料
 */
function dataUrlToBase64(dataUrl: string): string {
  const base64Index = dataUrl.indexOf(',');
  return base64Index >= 0 ? dataUrl.slice(base64Index + 1) : dataUrl;
}

/**
 * 獲取圖片副檔名
 */
function getImageExtension(filename: string): string {
  const ext = filename.split('.').pop()?.toLowerCase();
  return ext && ['jpg', 'jpeg', 'png', 'webp', 'bmp'].includes(ext) ? ext : 'jpg';
}

/**
 * 生成 YOLO data.yaml 配置檔案
 */
function generateDataYaml(classes: ClassDefinition[], datasetName: string): string {
  const classNames = classes.map((c) => c.name);
  return `# YOLO Dataset Configuration
# Generated by YOLO Web Platform

path: .
train: images/train
val: images/val

nc: ${classes.length}
names: [${classNames.map((n) => `'${n}'`).join(', ')}]

# Dataset: ${datasetName}
# Generated at: ${new Date().toISOString()}
`;
}

/**
 * 生成 classes.txt 檔案
 */
function generateClassesTxt(classes: ClassDefinition[]): string {
  return classes.map((c) => c.name).join('\n');
}

/**
 * 生成 README.md 說明文檔
 */
function generateReadme(dataset: Dataset, imageCount: { train: number; val: number }): string {
  return `# ${dataset.name}

YOLO 格式資料集，由 YOLO Web Platform 導出。

## 目錄結構

\`\`\`
${dataset.name}/
├── images/
│   ├── train/    # 訓練圖片 (${imageCount.train} 張)
│   └── val/      # 驗證圖片 (${imageCount.val} 張)
├── labels/
│   ├── train/    # 訓練標註
│   └── val/      # 驗證標註
├── classes.txt   # 類別列表
├── data.yaml     # YOLO 配置檔案
└── README.md     # 本說明文件
\`\`\`

## 類別資訊

| ID | 名稱 |
|----|------|
${dataset.classes.map((c) => `| ${c.id} | ${c.name} |`).join('\n')}

## 使用方式

### YOLOv5
\`\`\`bash
python train.py --data data.yaml --weights yolov5s.pt --epochs 100
\`\`\`

### YOLOv8
\`\`\`bash
yolo train data=data.yaml model=yolov8n.pt epochs=100
\`\`\`

## 資料集資訊

- 創建時間: ${dataset.createdAt.toLocaleString()}
- 總圖片數: ${dataset.imageIds.length}
- 訓練集: ${imageCount.train} 張 (${(dataset.trainRatio * 100).toFixed(0)}%)
- 驗證集: ${imageCount.val} 張 (${((1 - dataset.trainRatio) * 100).toFixed(0)}%)
- 類別數量: ${dataset.classes.length}
`;
}

/**
 * 導出資料集為 YOLO 格式 ZIP
 */
export async function exportDatasetAsYOLO(
  dataset: Dataset,
  images: ImageAnnotation[],
  options: ExportOptions,
  onProgress?: ProgressCallback
): Promise<Blob> {
  const zip = new JSZip();
  const imageMap = new Map(images.map((img) => [img.id, img]));

  // 獲取訓練集和驗證集圖片
  const trainImages = dataset.trainImageIds
    .map((id) => imageMap.get(id))
    .filter((img): img is ImageAnnotation => img !== undefined);

  const valImages = dataset.valImageIds
    .map((id) => imageMap.get(id))
    .filter((img): img is ImageAnnotation => img !== undefined);

  const totalSteps = (options.includeImages ? trainImages.length + valImages.length : 0) +
    trainImages.length + valImages.length + 3; // labels + config files

  let currentStep = 0;

  const reportProgress = (phase: ExportProgress['phase'], message: string) => {
    currentStep++;
    onProgress?.({
      current: currentStep,
      total: totalSteps,
      phase,
      message,
    });
  };

  // 準備階段
  reportProgress('preparing', '準備導出...');

  // 導出圖片（如果需要）
  if (options.includeImages) {
    for (const img of trainImages) {
      const ext = getImageExtension(img.filename);
      const baseName = img.filename.replace(/\.[^.]+$/, '');
      const path = options.splitFolders
        ? `images/train/${baseName}.${ext}`
        : `images/${baseName}.${ext}`;

      zip.file(path, dataUrlToBase64(img.dataUrl), { base64: true });
      reportProgress('images', `導出訓練圖片: ${img.filename}`);
    }

    for (const img of valImages) {
      const ext = getImageExtension(img.filename);
      const baseName = img.filename.replace(/\.[^.]+$/, '');
      const path = options.splitFolders
        ? `images/val/${baseName}.${ext}`
        : `images/${baseName}.${ext}`;

      zip.file(path, dataUrlToBase64(img.dataUrl), { base64: true });
      reportProgress('images', `導出驗證圖片: ${img.filename}`);
    }
  }

  // 導出標註
  for (const img of trainImages) {
    const baseName = img.filename.replace(/\.[^.]+$/, '');
    const labelContent = img.boxes.map(boxToYOLOLine).join('\n');
    const path = options.splitFolders
      ? `labels/train/${baseName}.txt`
      : `labels/${baseName}.txt`;

    zip.file(path, labelContent);
    reportProgress('labels', `導出訓練標註: ${baseName}.txt`);
  }

  for (const img of valImages) {
    const baseName = img.filename.replace(/\.[^.]+$/, '');
    const labelContent = img.boxes.map(boxToYOLOLine).join('\n');
    const path = options.splitFolders
      ? `labels/val/${baseName}.txt`
      : `labels/${baseName}.txt`;

    zip.file(path, labelContent);
    reportProgress('labels', `導出驗證標註: ${baseName}.txt`);
  }

  // 導出配置檔案
  reportProgress('config', '生成 classes.txt');
  zip.file('classes.txt', generateClassesTxt(dataset.classes));

  reportProgress('config', '生成 data.yaml');
  zip.file('data.yaml', generateDataYaml(dataset.classes, dataset.name));

  reportProgress('config', '生成 README.md');
  zip.file('README.md', generateReadme(dataset, {
    train: trainImages.length,
    val: valImages.length,
  }));

  // 壓縮
  onProgress?.({
    current: totalSteps,
    total: totalSteps,
    phase: 'compressing',
    message: '壓縮檔案中...',
  });

  return await zip.generateAsync({
    type: 'blob',
    compression: 'DEFLATE',
    compressionOptions: { level: 6 },
  });
}

/**
 * 估算導出檔案大小
 */
export function estimateExportSize(
  dataset: Dataset,
  images: ImageAnnotation[],
  options: ExportOptions
): number {
  const imageMap = new Map(images.map((img) => [img.id, img]));
  let totalSize = 0;

  // 圖片大小
  if (options.includeImages) {
    for (const id of dataset.imageIds) {
      const img = imageMap.get(id);
      if (img) {
        // base64 大小約為原始大小的 4/3，壓縮後約 70%
        totalSize += (img.dataUrl.length * 3 / 4) * 0.7;
      }
    }
  }

  // 標註檔案大小（每行約 50 bytes）
  for (const id of dataset.imageIds) {
    const img = imageMap.get(id);
    if (img) {
      totalSize += img.boxes.length * 50;
    }
  }

  // 配置檔案（約 2KB）
  totalSize += 2048;

  return totalSize;
}

/**
 * 觸發下載
 */
export function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
